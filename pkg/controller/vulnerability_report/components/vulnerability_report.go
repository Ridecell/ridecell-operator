/*
Copyright 2020 Ridecell, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package components

import (
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/Ridecell/ridecell-operator/pkg/components"
	aquav1alpha1 "github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	sh "github.com/aws/aws-sdk-go/service/securityhub"
	"github.com/aws/aws-sdk-go/service/securityhub/securityhubiface"
	"github.com/golang/glog"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type reportComponent struct {
	shAPI securityhubiface.SecurityHubAPI
}

func NewVulnerabilityReport() *reportComponent {
	sess := session.Must(session.NewSession())
	shService := sh.New(sess, &aws.Config{
		Region: aws.String("us-west-2"), // All vulneribilty report should go to us-west-2 region only.
	})
	return &reportComponent{shAPI: shService}
}

func (comp *reportComponent) InjectIAMAPI(shapi securityhubiface.SecurityHubAPI) {
	comp.shAPI = shapi
}

func (_ *reportComponent) WatchTypes() []runtime.Object {
	return []runtime.Object{}
}

func (_ *reportComponent) IsReconcilable(_ *components.ComponentContext) bool {
	return true
}

func (comp *reportComponent) Reconcile(ctx *components.ComponentContext) (components.Result, error) {
	reportList := &aquav1alpha1.VulnerabilityReportList{}

	awsAccId := os.Getenv("AWS_ACCOUNT_ID")
	awsRegion := "us-west-2" // All vulneribilty report should go to us-west-2 region only.

	if awsAccId == "" {
		glog.Errorf("vulnerability_report: AWS_ACCOUNT_ID environment variable not set.")
		return components.Result{}, nil
	}

	// Select all vulnerabilityreport objects without "ridecell.io/aws-security-hub" label
	listOptions := &client.ListOptions{}
	err := listOptions.SetLabelSelector("!ridecell.io/aws-security-hub")
	if err != nil {
		glog.Errorf("vulnerability_report: Invalid label selector: %s", err)
		return components.Result{}, nil
	}

	err = ctx.List(ctx.Context, listOptions, reportList)
	if err != nil {
		glog.Errorf("vulnerability_report: failed to list vulneribilty report objects")
		return components.Result{RequeueAfter: time.Second * 15}, nil
	}

	for _, report := range reportList.Items {
		addLabel := true
		imageTag := fmt.Sprintf("%s/%s:%s", report.Report.Registry.Server, report.Report.Artifact.Repository, report.Report.Artifact.Tag)

		batchInput := &sh.BatchImportFindingsInput{
			Findings: []*sh.AwsSecurityFinding{},
		}

		bufferFindingsArray := []*sh.AwsSecurityFinding{}
		//vulneribiltyPostCounter := 0
		for _, vulneribilty := range report.Report.Vulnerabilities {
			// Severity
			severityNumber := func() int {
				switch vulneribilty.Severity {
				case "LOW":
					return 1
				case "MEDIUM":
					return 4
				case "HIGH":
					return 7
				case "CRITICAL":
					return 9
				default: // Handles NONE and UNKNOWN Severity
					return 0
				}
			}()
			// Popolate batch import type data
			securityFinding := &sh.AwsSecurityFinding{
				SchemaVersion: aws.String("2018-10-08"),
				AwsAccountId:  aws.String(awsAccId),
				GeneratorId:   aws.String("Trivy"),
				Id:            aws.String(fmt.Sprintf("%s / %s", imageTag, vulneribilty.VulnerabilityID)),
				ProductArn:    aws.String(fmt.Sprintf("arn:aws:securityhub:%s::product/aquasecurity/aquasecurity", awsRegion)),
				Types: []*string{
					aws.String("Software and Configuration Checks/Vulnerabilities/CVE"),
				},
				CreatedAt: aws.String(time.Now().Format(time.RFC3339)),
				UpdatedAt: aws.String(time.Now().Format(time.RFC3339)),
				Severity: &sh.Severity{
					//Label:    aws.String(vul_Severity),
					//Original: aws.String(vul_Severity),
					Normalized: aws.Int64(int64(severityNumber * 10)),
					Product:    aws.Float64(float64(severityNumber)),
				},
				Title:       aws.String(fmt.Sprintf("Trivy found a vulnerability to %s in container %s", vulneribilty.VulnerabilityID, imageTag)),
				ProductFields: map[string]*string{
					"Product Name": aws.String("Trivy"),
				},
				Resources: []*sh.Resource{
					&sh.Resource{
						Type:      aws.String("Container"),
						Id:        aws.String(imageTag),
						Partition: aws.String("aws"),
						Region:    aws.String(awsRegion),
						Details: &sh.ResourceDetails{
							Container: &sh.ContainerDetails{
								ImageName: aws.String(imageTag),
							},
							Other: map[string]*string{
								"CVE ID":            aws.String(vulneribilty.VulnerabilityID),
								"CVE Title":         aws.String(vulneribilty.Title),
								"PkgName":           aws.String(vulneribilty.Resource),
								"Installed Package": aws.String(vulneribilty.InstalledVersion),
								"Patched Package":   aws.String(vulneribilty.FixedVersion),
							},
						},
					},
				},
				RecordState: aws.String("ACTIVE"),
			}

			//if Remediation link present, then add it.
			if len(vulneribilty.Links) > 0 {
				securityFinding.Remediation = &sh.Remediation{
					Recommendation: &sh.Recommendation{
						Text: aws.String("More information on this vulnerability is provided in the hyperlink"),
						Url:  aws.String(vulneribilty.Links[0]),
					},
				}
			}
			// Add description if empty
			if vulneribilty.Description == "" {
				securityFinding.Description = aws.String("No description provided")
			} else {
				securityFinding.Description = aws.String(vulneribilty.Description)
			}
			// Append findings
			bufferFindingsArray = append(bufferFindingsArray, securityFinding)
		}

		// Send maximum 100 findings in 1 call
		if len(bufferFindingsArray) > 100 {
			for len(bufferFindingsArray) >= 100 {
				batchInput.Findings = bufferFindingsArray[:100]
				bufferFindingsArray = bufferFindingsArray[100:]
				// Calculate size of payload
				b, _ := json.Marshal(batchInput)
				glog.Infof("vulneribilty_report: batchimport size in bytes: %d for image: %s", len(b), imageTag)

				// AWS Api operation has requests limit per sencond
				time.Sleep(200 * time.Millisecond)
				//send data to aws
				batchOutput, err := comp.shAPI.BatchImportFindings(batchInput)
				if err != nil || (batchOutput != nil && aws.Int64Value(batchOutput.FailedCount) > int64(0)){
					addLabel = false
					glog.Errorf("vulneribilty_report: batchimport failed for image %s : %s %s", imageTag, batchOutput, err)
					break
				}
			}
		}
		// send directly
		if len(bufferFindingsArray) <= 100 {
			batchInput.Findings = bufferFindingsArray[:len(bufferFindingsArray)]
			// Calculate size of payload
			b, _ := json.Marshal(batchInput)
			glog.Infof("vulneribilty_report: batchimport size in bytes: %d for image: %s", len(b), imageTag)

			// AWS Api operation has requests limit per sencond
			time.Sleep(200 * time.Millisecond)
			//send data to aws
			batchOutput, err := comp.shAPI.BatchImportFindings(batchInput)
			if err != nil || (batchOutput != nil && aws.Int64Value(batchOutput.FailedCount) > int64(0)){
				addLabel = false
				glog.Errorf("vulneribilty_report: batchimport failed for image %s : %s %s", imageTag, batchOutput, err)
			}
		}

		if addLabel {
			// If all vulneribilities posted to security hub, then add label to VulnerabilityReport object
			reportObj := &aquav1alpha1.VulnerabilityReport{}
			err = ctx.Get(ctx.Context, types.NamespacedName{Name: report.Name, Namespace: report.Namespace}, reportObj)
			if err != nil {
				glog.Errorf("vulneribilty_report: unable to get VulnerabilityReport object: %s", err)
				continue
			}
			reportObj.Labels["ridecell.io/aws-security-hub"] = "synced"
			err = ctx.Update(ctx.Context, reportObj)
			if err != nil {
				glog.Errorf("vulneribilty_report: unable to add label: %s", err)
			}
		}

	}

	return components.Result{}, nil
}
