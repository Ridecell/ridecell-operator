/*
Copyright 2020 Ridecell, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package components

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/Ridecell/ridecell-operator/pkg/components"
	aquav1alpha1 "github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	sh "github.com/aws/aws-sdk-go/service/securityhub"
	"github.com/aws/aws-sdk-go/service/securityhub/securityhubiface"
	"github.com/golang/glog"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type reportComponent struct {
	shAPI securityhubiface.SecurityHubAPI
}

func NewVulnerabilityReport() *reportComponent {
	sess := session.Must(session.NewSession())
	shService := sh.New(sess, &aws.Config{
		Region: aws.String("us-west-2"), // All vulneribilty report should go to us-west-2 region only.
	})
	return &reportComponent{shAPI: shService}
}

func (comp *reportComponent) InjectSecurityHubAPI(shapi securityhubiface.SecurityHubAPI) {
	comp.shAPI = shapi
}

func (_ *reportComponent) WatchTypes() []runtime.Object {
	return []runtime.Object{}
}

func (_ *reportComponent) IsReconcilable(_ *components.ComponentContext) bool {
	return true
}

func (comp *reportComponent) Reconcile(ctx *components.ComponentContext) (components.Result, error) {
	reportList := &aquav1alpha1.VulnerabilityReportList{}

	awsAccId := os.Getenv("AWS_ACCOUNT_ID")
	awsRegion := "us-west-2" // All vulneribilty report should go to us-west-2 region only.

	if awsAccId == "" {
		glog.Errorf("vulnerability_report: AWS_ACCOUNT_ID environment variable not set.")
		return components.Result{}, nil
	}

	// Select all vulnerabilityreport objects without "ridecell.io/aws-security-hub" label
	listOptions := &client.ListOptions{}
	err := listOptions.SetLabelSelector("!ridecell.io/aws-security-hub")
	if err != nil {
		glog.Errorf("vulnerability_report: Invalid label selector: %s", err)
		return components.Result{}, nil
	}

	err = ctx.List(ctx.Context, listOptions, reportList)
	if err != nil {
		glog.Errorf("vulnerability_report: failed to list vulneribilty report objects")
		return components.Result{RequeueAfter: time.Second * 15}, nil
	}

	for _, report := range reportList.Items {
		addLabel := true
		imageRepo := strings.Split(report.Report.Artifact.Repository, "/")
		imageTag := fmt.Sprintf("%s:%s", imageRepo[len(imageRepo)-1], report.Report.Artifact.Tag)

		batchInput := &sh.BatchImportFindingsInput{
			Findings: []*sh.AwsSecurityFinding{},
		}

		bufferFindingsArray := []*sh.AwsSecurityFinding{}
		//vulneribiltyPostCounter := 0
		for _, vulneribilty := range report.Report.Vulnerabilities {
			// Severity
			severityNumber := func() int {
				switch vulneribilty.Severity {
				case "LOW":
					return 1
				case "MEDIUM":
					return 4
				case "HIGH":
					return 7
				case "CRITICAL":
					return 9
				default: // Handles NONE and UNKNOWN Severity
					return 0
				}
			}()
			// Popolate batch import type data
			securityFinding := &sh.AwsSecurityFinding{
				SchemaVersion: aws.String("2018-10-08"),
				AwsAccountId:  aws.String(awsAccId),
				GeneratorId:   aws.String("Trivy"),
				Id:            aws.String(fmt.Sprintf("%s / %s", imageTag, vulneribilty.VulnerabilityID)),
				ProductArn:    aws.String(fmt.Sprintf("arn:aws:securityhub:%s::product/aquasecurity/aquasecurity", awsRegion)),
				Types: []*string{
					aws.String("Software and Configuration Checks/Vulnerabilities/CVE"),
				},
				CreatedAt: aws.String(time.Now().Format(time.RFC3339)),
				UpdatedAt: aws.String(time.Now().Format(time.RFC3339)),
				Severity: &sh.Severity{
					//Label:    aws.String(vul_Severity),
					//Original: aws.String(vul_Severity),
					Normalized: aws.Int64(int64(severityNumber * 10)),
					Product:    aws.Float64(float64(severityNumber)),
				},
				Title: aws.String(fmt.Sprintf("Trivy found a vulnerability to %s in container %s", vulneribilty.VulnerabilityID, imageTag)),
				ProductFields: map[string]*string{
					"Product Name": aws.String("Trivy"),
				},
				Resources: []*sh.Resource{
					&sh.Resource{
						Type:      aws.String("Container"),
						Id:        aws.String(imageTag),
						Partition: aws.String("aws"),
						Region:    aws.String(awsRegion),
						Details: &sh.ResourceDetails{
							Container: &sh.ContainerDetails{
								ImageName: aws.String(imageTag),
							},
							Other: map[string]*string{
								"CVE ID":            aws.String(vulneribilty.VulnerabilityID),
								"CVE Title":         aws.String(vulneribilty.Title),
								"PkgName":           aws.String(vulneribilty.Resource),
								"Installed Package": aws.String(vulneribilty.InstalledVersion),
								"Patched Package":   aws.String(vulneribilty.FixedVersion),
							},
						},
					},
				},
				RecordState: aws.String("ACTIVE"),
			}

			//if Remediation link present, then add it.
			if validLink := getValidLink(vulneribilty.Links); validLink != "" {
				glog.Infof("vulneribilty_report: Remediation URL: %s", validLink)
				securityFinding.Remediation = &sh.Remediation{
					Recommendation: &sh.Recommendation{
						Text: aws.String("More information on this vulnerability is provided in the hyperlink"),
						Url:  aws.String(validLink),
					},
				}
			}
			// Add description if empty
			if vulneribilty.Description == "" {
				securityFinding.Description = aws.String("No description provided")
			} else {
				// limit is 1024 chars only
				securityFinding.Description = func() *string {
					if len(vulneribilty.Description) > 1024 {
						return aws.String(vulneribilty.Description[:1024])
					}
					return aws.String(vulneribilty.Description)
				}()
			}
			// Append findings
			bufferFindingsArray = append(bufferFindingsArray, securityFinding)
		}

		// Divide and send data, maximum 100 findings per batch.
		maxLimit := 100
		bufferFindingsArrayLength := len(bufferFindingsArray)

		for i := 0; i < bufferFindingsArrayLength; i += maxLimit {
			end := func() int {
				if (i + maxLimit) <= bufferFindingsArrayLength {
					return i + maxLimit
				}
				return bufferFindingsArrayLength
			}()

			batchInput.Findings = bufferFindingsArray[i:end]
			success := comp.sendData(batchInput, imageTag)
			if !success {
				addLabel = false // We just want to assign false value, not true
				break
			}
		}

		if addLabel {
			// If all vulneribilities posted to security hub, then add label to VulnerabilityReport object
			reportObj := &aquav1alpha1.VulnerabilityReport{}
			err = ctx.Get(ctx.Context, types.NamespacedName{Name: report.Name, Namespace: report.Namespace}, reportObj)
			if err != nil {
				glog.Errorf("vulneribilty_report: unable to get VulnerabilityReport object: %s", err)
				continue
			}
			if reportObj.Labels == nil {
				reportObj.Labels = map[string]string{}
			}
			reportObj.Labels["ridecell.io/aws-security-hub"] = "synced"
			err = ctx.Update(ctx.Context, reportObj)
			if err != nil {
				glog.Errorf("vulneribilty_report: unable to add label: %s", err)
			}
		}
	}

	return components.Result{}, nil
}

func (comp *reportComponent) sendData(batchInput *sh.BatchImportFindingsInput, imageTag string) bool {
	// Calculate size of payload
	b, _ := json.Marshal(batchInput)
	glog.Infof("vulneribilty_report: batchimport size in bytes: %d for image: %s", len(b), imageTag)

	// AWS Api operation has requests limit per sencond
	time.Sleep(200 * time.Millisecond)

	// Send data to aws
	batchOutput, err := comp.shAPI.BatchImportFindings(batchInput)
	if err != nil || (batchOutput != nil && aws.Int64Value(batchOutput.FailedCount) > int64(0)) {
		glog.Errorf("vulneribilty_report: batchimport failed for image %s : %s %s", imageTag, batchOutput, err)
		return false
	}
	return true
}

func getValidLink(links []string) string {
	for _, link := range links {
		if u, err := url.ParseRequestURI(strings.Split(link, " ")[0]); err == nil {
			return u.String()
		}
	}
	return ""
}
