/*
Copyright 2019 Ridecell, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package components

import (
	"fmt"
	"os"
	"time"

	"github.com/Ridecell/ridecell-operator/pkg/components"
	aquav1alpha1 "github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	sh "github.com/aws/aws-sdk-go/service/securityhub"
	"github.com/aws/aws-sdk-go/service/securityhub/securityhubiface"
	"github.com/golang/glog"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type reportComponent struct {
	shAPI securityhubiface.SecurityHubAPI
}

func NewVulnerabilityReport() *reportComponent {
	sess := session.Must(session.NewSession())
	shService := sh.New(sess, &aws.Config{
		Region: aws.String("us-west-2"), // All vulneribilty report should go to us-west-2 region only.
	})
	return &reportComponent{shAPI: shService}
}

func (comp *reportComponent) InjectIAMAPI(shapi securityhubiface.SecurityHubAPI) {
	comp.shAPI = shapi
}

func (_ *reportComponent) WatchTypes() []runtime.Object {
	return []runtime.Object{&aquav1alpha1.VulnerabilityReport{}}
}

func (_ *reportComponent) IsReconcilable(_ *components.ComponentContext) bool {
	return true
}

func (comp *reportComponent) Reconcile(ctx *components.ComponentContext) (components.Result, error) {
	reportList := &aquav1alpha1.VulnerabilityReportList{}

	awsAccId := os.Getenv("AWS_ACCOUNT_ID")
	awsRegion := "us-west-2" // All vulneribilty report should go to us-west-2 region only.

	// Select all vulnerabilityreport objects without "ridecell.io/aws-security-hub" label
	listOptions := &client.ListOptions{}
	err := listOptions.SetLabelSelector("!ridecell.io/aws-security-hub")
	if err != nil {
		glog.Errorf("vulnerability_report: Invalid label selector: %s", err)
		return components.Result{}, nil
	}

	err = ctx.List(ctx.Context, listOptions, reportList)
	if err != nil {
		glog.Errorf("vulnerability_report: failed to list vulneribilty report objects")
		return components.Result{RequeueAfter: time.Second * 15}, nil
	}

	for _, report := range reportList.Items {
		imageTag := fmt.Sprintf("%s/%s:%s", report.Report.Registry.Server, report.Report.Artifact.Repository, report.Report.Artifact.Tag)

		vulneribiltyPostCounter := 0
		for _, vulneribilty := range report.Report.Vulnerabilities {
			// Severity
			severityNumber := func() int {
				switch vulneribilty.Severity {
				case "LOW":
					return 1
				case "MEDIUM":
					return 4
				case "HIGH":
					return 7
				case "CRITICAL":
					return 9
				default: // Handles NONE and UNKNOWN Severity
					return 0
				}
			}()
			// Popolate batch import type data
			batchInput := &sh.BatchImportFindingsInput{
				Findings: []*sh.AwsSecurityFinding{
					&sh.AwsSecurityFinding{
						SchemaVersion: aws.String("2018-10-08"),
						AwsAccountId:  aws.String(awsAccId),
						GeneratorId:   aws.String("Trivy"),
						Id:            aws.String(fmt.Sprintf("%s / %s", imageTag, vulneribilty.VulnerabilityID)),
						ProductArn:    aws.String(fmt.Sprintf("arn:aws:securityhub:%s::product/aquasecurity/aquasecurity", awsRegion)),
						Types: []*string{
							aws.String("Software and Configuration Checks/Vulnerabilities/CVE"),
						},
						CreatedAt: aws.String(time.Now().Format(time.RFC3339)),
						UpdatedAt: aws.String(time.Now().Format(time.RFC3339)),
						Severity: &sh.Severity{
							//Label:    aws.String(vul_Severity),
							//Original: aws.String(vul_Severity),
							Normalized: aws.Int64(int64(severityNumber * 10)),
							Product:    aws.Float64(float64(severityNumber)),
						},
						Title:       aws.String(fmt.Sprintf("Trivy found a vulnerability to %s in container %s", vulneribilty.VulnerabilityID, imageTag)),
						Description: aws.String(vulneribilty.Description),
						ProductFields: map[string]*string{
							"Product Name": aws.String("Trivy"),
						},
						Resources: []*sh.Resource{
							&sh.Resource{
								Type:      aws.String("Container"),
								Id:        aws.String(imageTag),
								Partition: aws.String("aws"),
								Region:    aws.String(awsRegion),
								Details: &sh.ResourceDetails{
									Container: &sh.ContainerDetails{
										ImageName: aws.String(imageTag),
									},
									Other: map[string]*string{
										"CVE ID":            aws.String(vulneribilty.VulnerabilityID),
										"CVE Title":         aws.String(vulneribilty.Title),
										"PkgName":           aws.String(vulneribilty.Resource),
										"Installed Package": aws.String(vulneribilty.InstalledVersion),
										"Patched Package":   aws.String(vulneribilty.FixedVersion),
									},
								},
							},
						},
						RecordState: aws.String("ACTIVE"),
					},
				},
			}

			//if Remediation link present, then add it.
			if len(vulneribilty.Links) > 0 {
				batchInput.Findings[0].Remediation = &sh.Remediation{
					Recommendation: &sh.Recommendation{
						Text: aws.String("More information on this vulnerability is provided in the hyperlink"),
						Url:  aws.String(vulneribilty.Links[0]),
					},
				}
			}

			//send data to aws
			batchOutput, err := comp.shAPI.BatchImportFindings(batchInput)
			if err != nil {
				glog.Errorf("vulneribilty_report: failed to post findings: %s", err)
			}
			//check batch import output for failure count
			//if failure count >0, log it
			if batchOutput != nil {
				if aws.Int64Value(batchOutput.FailedCount) > int64(0) {
					glog.Errorf("vulneribilty_report: batchimport failed: %s", batchOutput)
				} else {
					vulneribiltyPostCounter = vulneribiltyPostCounter + 1
				}
			}
		}

		// If all vulneribilities posted to security hub, then add label to VulnerabilityReport object
		if len(report.Report.Vulnerabilities) == vulneribiltyPostCounter {
			reportObj := &aquav1alpha1.VulnerabilityReport{}
			err = ctx.Get(ctx.Context, types.NamespacedName{Name: report.Name, Namespace: report.Namespace}, reportObj)
			if err != nil {
				glog.Errorf("vulneribilty_report: unable to get VulnerabilityReport object: %s", err)
				continue
			}
			reportObj.Labels["ridecell.io/aws-security-hub"] = "synced"
			err = ctx.Update(ctx.Context, reportObj)
			if err != nil {
				glog.Errorf("vulneribilty_report: unable to add label: %s", err)
			}
		}

	}

	return components.Result{}, nil
}
